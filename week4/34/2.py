#IO模型
#IO多路复用就是IO模型的一种
'''
我们需要知道:同步,异步,阻塞,非阻塞
阻塞IO
非阻塞IO
IO多路复用
信号驱动(几乎不会用到)
异步IO
#在讲上述之前要知道数据拷贝过程怎么发生的?




#阻塞IO例子:
#sk.setblocking() #决定你是不是阻塞的,默认是阻塞IO(也就是遇到accept,recv都会阻塞住,如果设置成非阻塞的话,name他就会直接过,就是说有数据他就直接拿过来,没有的话认为返回一个错误,继续往下走),
#先看之前学完的这些阻塞IO内部是怎么工作的?


'''
#阻塞IO
#recvfrom 是用来发系统调用的谁来发?
import socket
sk = socket.socket()
sk.bind()
sk.listen(3)
conn,address = sk.accept() #他会发系统调用
conn.recv() #他会发系统调用

#accept在这里一旦执行就会发系统调用,发过去之后OS就会做2件事情,(1)等待数据(2)转移数据
#转移好之后,这个数据就传过来了,整个过程然后会有一个接收,conn,addr,(这两个东西之后OS把数据转移到我用户区,我才能去用,这个过程才叫结束)
#那么整个过程处于一种阻塞状态((1)准备数据需要阻塞(2)OS把数据拷贝到用户区的时候也需要阻塞),这两个哪一个不完成我都不会往下走
#效率低,是我们的进程被阻塞掉了,你客户端一天不来数据,我就要等一天,那怎么解决?

#非阻塞IO
#如果在自己程序里面,我可以给他设定成非阻塞IO的,设置完这种模式,它内部怎么用的,怎么工作的?
#(设定完不管你有没有数据,都会往下执行,如果有数据就把数据给你取过来,没有就返回一个错误[就是告诉你没有数据],不管有没有错都往下走),
#那么问题来了?他就一直往单线的下走吗?,如果是的话,就等于把这个IO给放弃掉了,你什么时候拿数据我就不知道了,肯定不行,所以应该怎么搞?
#可不可以循环的发recvfrom,那么怎么发?我上来就发recvfrom,发完之后,有数据你给我,没有就给我一个信息,就告诉我没数据,不论这样结果如何我都能得到一个明确的信息,
#接下来没数据我可以继续往下走,我在发一个recvfrom,可以再问你一下,这样一直下去,就相当于反复的轮询的去问,这样中间的这段时间他就可以干别的了,
#一直到OS给我说OK了数据来了,这样我就可以把这个任务解决掉,比刚才阻塞IO好一些,(其实这样一直问一直问消耗资源很大),总之这个机制比刚才的好,中间我可以干别的
#强调的问题:如果有数据了,就可以把数据拷贝到用户区了,那么recvfrom彼此之间是阻塞的吗?肯定不是,我目的就是在中间可以做点别的,你在给阻塞调,还有什么意义啊,不是阻塞的,就可以运行其他的命令,意味着这时候他就有cpu的权限
#我们说只有阻塞的时候,才没有cpu权限,[但是copy的时候是阻塞的,阻塞与非阻塞,就是说大家第一个阶段是不一样的,一个是问一次一直等,一个是一直轮训的问,中间过程可以干其他的,但是第二个阶段copy的阶段是一样的]
#所以说第二个过程也是阻塞的:
#那么这个模式的弊端:
#(1)数据不能及时拿到的问题,就是说我不管多久询问一次,外一你不是当时就告诉我的,而是说在我做其他的事情过程中,你数据过来了,我不能及时拿到,这相当于有了一个延迟,这是一个很大的问题
#(2)一直问比较开销大
#总结:与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 把cpu拿到自己手里。即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的，
#需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。


#IO多路复用
#[题外话]
#sockeserver源码就用到了select
#nginx内部实现机制通过epoll实现的,全在于epoll这么吊
#不管是select poll epoll它都属于IO多路复用的表现形式,只不过epoll比select更强大,机制更优越
#有些地方也称这种IO方式为event driven IO(事件驱动IO)

#第三张图解释
#select就是一个函数调用,他也会发一个系统调用,之后OS等待数据,......一直没结果,这个过程肯定也是阻塞的
#只不过这个阻塞跟刚才的不一样的(刚才阻塞是通过recv,accept完成的阻塞,现在是通过select完成的阻塞,而这个阻塞也是等待数据,现在是由select做等待数据的过程,那么他做有什么好处[数据一旦到了我们内核区,他会返回一个readable,其实readble就是告诉用户(就是你的进程)数据已经到了,return给进程告诉你数据可读了])
#内核区发完return readable之后,那么下一个动作谁来发生?(是进程,进程会告诉内核说你把数据给我拷贝过来把,这个时候,我们的进程并不是什么事都没干,这个过程中进程如果不发个系统调用告诉OS,OS不会做这件事情[帮你把数据copy过来这件事]),
#所以对比之前,之前两个发完系统调用之后,我们没有通知OS说把这个数据copy过来,这两个动作一气呵成OS都给你做了[1个数据过来,2个copy数据],中间不用再告诉OS,但是这是因为你在发系统调用了,
#但是当我们用IO多路复用这个时候通过select函数做数据监听,监听完,select返回的只是说OS已经有数据了,但是并没有让OS给你copy到用户区,所以这个时候你需要发一个系统调用之后,他才会把数据转到用户区,这是整个一个实现过程,当然这个数据准备好之后,他在告诉你的进程说数据准备好了,你可以用了,这是他的一个机制,无论是select,epool内部根本机制都是这么来玩的
#那么这个机制有什么好处,为甚大量用IO多路复用?
#这个机制是只要select函数调用,整个进程阻塞住,在数据到达之前,完全是停住的,之后我的进程发一个系统调用在把数据拷贝过来,这个过程也是阻塞的,说白了这个过程跟第一个没啥区别啊,甚至比第一个还多一步(你还要告诉OS把数据给我转移过来),其实真的是没啥好处,在这个表现形式上真的是没任何好处,但是他就是解决了一个问题,一个足以让其他方式都解决不了的问题,就是我的select可以监听多个描述符
#意思就是说可以等待可能连接的多个socket连接,其实就是多个文件描述符,就这一个优点,我select里面的参数可以不止一个了,可以有多个,你无论哪个来我都可以给你连接,而这个时候就可以通过它实现并发效果,之前的都不行,只有select,但是整个过程也是阻塞的
#但是他解决了并发,这个过程并不是进程来阻塞的,select用的时候只是一个函数,通过调用底层select一个机制来完成的,虽然都是阻塞,但是触发的原因是不一致的,select是跨平台的(唯一的优点)
#epoll是在select基础上做的一个完善,但是机制都是一样的,都是做了两个阻塞,最关键的可以监听多个文件描述符


#异步IO(最牛的),实现机制麻烦
#过程:当程序执行,首先发个系统调用,之后立刻有一个return值,有数据就拿走,没有的话,我也能知道这个情况(类似于非阻塞IO),没数据之后,waiting for data,OS在这等数据,等完之后copy,区别在于这个过程中进程不在阻塞,进程可以干别的,是完全没有阻塞的,你什么时候数据到了发一个通知给我就行了,我什么时候用你都不用管,但实现起来麻烦
#epoll不是异步IO,他只是IO多路复用的一种,他内部有阻塞,异步IO是完全没有阻塞的

#总结:4种模型比喻一种生活场景(买票):
#(1)阻塞IO:排队等票,不能干别的
#(2)非阻塞IO:买票,每10分钟过来看一下票到了吗?,时间分段,可以干别的事情,最后通知你票到了的时候,你要去窗口取票(相当于阻塞)
#(3)异步IO:相当于跟那个人打了电话,不用排队,什么都不用关心
#(4),调用select不用排队,不同的窗口可以通知你,哪个窗口到了,哪个通知你

#问题:selectIo为什么叫事件驱动IO.跟刚才讲的事件驱动有什么关系?

#IO多路复用之select
#他就是通过调用select方法,让OS监听多个描述符,而哪一个文件描述符一旦有了数据之后,他在给我转过来
#他到底是怎么个事件驱动?
#它非常粗糙,比如让他监听10个文件描述符,他会轮询监听[就跟上午讲的事件驱动的时候,有一个队列一样,专门有一个线程去取数据,只要有事件放里面,证明事件被出发了,他就有一个线程专门把对于的这个函数执行了],其实select跟她一样
#他也会去监听,它监听放入的10个fd有没有数据更新,如果有说明这里面是有新的内容的,那么这个时候会把内容给你返回来,会吧数据从用户区搞到内核区,如果没有就睡眠,这样一直睡眠监听睡眠监听,永远属于这种循环状态,
#他这里是在监听所有的fd,依次监听(就相当于有10个人,挨个问你数据好没好,你数据好没好一样,比如第9个人好了,那么他会把第9个人的数据哪过来,那么我什么时候问呢?是你监听到的时候问,一直阻塞到你有数据来了[比如8个socket对象,这8个不可能同时有数据,假如第5个接收到数据了,对于我来说我只是知道这8个人有人接收到数据了,但是具体哪个有我并不知道,所以我的select内部做了一个轮询,怎么做的?(就是内部挨个问,问到第5个他说有数据,我拿到数据,紧接着他还会问下去,因为它也并不知道接收到数据的有几个FD,他这样问题很大,就是我这里要是40个人呢?40个人可能就一个接收到数据,他是不是要问一遍,才能确定下来,把这个数据接收到,这是一个低效的表现,这种轮询机制非常麻烦)])
# ,总结就是你们这40个人有数据更新的了,但是我这只知道有数据更新了,需要一个一个问,问完一遍之后才确定,在把数据更新这几个对象的内容从内核区copy到用户区,还有一个弊端就是监听的文件描述符有限的,好像只能监听1024个,超了就不监听了,这个机制很好,但轮询的效果很糟糕

#IO多路复用之poll
#他属于一个过渡阶段,然而并没解决什么问题,大的机制没变,就多了一个改进,在select基础上增加了FD的监听数量,理论上无限加,可以监听很多个文件描述符了


#IO多路复用之epoll
#它真正的解决了select的轮询问题,他怎么做的呢?(比如40个人,考试发卷子,谁写完了提交给我数据,如果是select他是这么做的[相当于你们每个人桌子上有一个按钮,谁想交卷了,按一下按钮,我这有一个灯,但我不知道谁要交,我要一个一个的去问,问完之后,我看谁想交在把卷子收上来],对于epoll呢?谁想交卷我这不光有一个灯,还有学生信息,到底是谁想交卷,那个信息就会显示,我直接去他那收就行了,如果同时向交卷,我就去他们两个那拿,我并不需要在把所有的人轮询一遍),它节省了大量的CPU时间
#但是一定要注意:epoll不是异步的,因为它属于IO多路复用的一种,拷贝状态还是阻塞的,异步是完全没有阻塞的,所以它属于同步
#copy的时候 fd不是很大的话,也不是很耗时
#注册一个函数,有队列更新的 ---19:11 这里











