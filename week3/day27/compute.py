#-*-coding:utf-8-*-
import time,threading
begin = time.time()
def add(n):
    sum = 0
    for i  in range(n):
        sum += i
    print(sum)

#add(50000000)
#add(80000000) #25秒

t1 = threading.Thread(target=add,args=(50000000,))
t1.start()
t2 = threading.Thread(target=add,args=(80000000,))
t2.start()

t1.join()
t2.join()
end = time.time() #36秒
print(end - begin)
#并行为什么比串行慢?
#CPU切换消耗时间,当前状态需要保存住

#IO密集型任务或函数:会有个等待(阻塞状态),告诉CPU不需要执行了
#计算密集型任务或函数:反之没有等待状态叫做计算密集型

#java开多线程,计算密集型任务或函数怎么处理
#如果只有一个cpu计算密集型的,的确没办法,就一个cpu两个任务都想执行没必要切换了
#一个解决不了可以多个
#多线程:可以让两个线程并行的去跑,刚才的例子都是并发情况,用一个cpu你们接着跑,这样看上去我的python只这一个cpu啊
#这就是python bug一般存在的gil->全局解释器锁->导致没法解决这种计算密集型的多线程
#2.7里面计算密集型线程比不用线程慢了一倍,3.5里面已经优化的很好了

#GIL
#电脑有多盒cpu确用不上
#这个不是python上的bug是解释器的bug(cpython->只有他有这问题(因为他是通用的),jpython,pypy)
#GIL对我们的影响:在同一时刻只能有一个线程进入我的解释器
#为什么要有这把锁:
#什么语言都有这个问题,2个线程都去同时拿这个数据肯定有安全问题,这个开发者就直接加了把锁,简单粗暴,因为当时是单核不是多核,没有发现这个问题,后来发现了
#python说白了没有多线程,语言层面上加了一把大锁为了以后开发python用,但对于我们是个大bug

#其他语言锁都自己加,什么时候用到自己加,把枷锁操作交给程序员自己了

#多线程很重要
#没事两个途径:
#解释器既然不让线程同一时刻跑,
#多进程可以同时进入cpython解释器

#后期解决gil问题想法是每个进程存一个线程,让进程同时进入解释器
#这个想法不完美,因为线程跟进程是不一样的,
# 线程可以共享数据,进程就不行了,进程的话彼此独立的,后期队列,或中间进程进行弥补这个问题,
#以及协程(线程竞争似的抢占资源,但是协程不抢,大家商量着来,你干完我干,他本身就是一个线程,能完成并发效果,有人说但不还是一个cpu吗,是啊,但是他可以加多进程啊,我在一个线程里面用协程,然后开多个进程写这个协程)
#
#-------------------重要的结论:
#在python里:如果任务IO密集型可以用多线程,如果是计算密集型,对不起改C,会C基础的话

#协程还是针对IO密集型的,他对计算密集型的一样没办法,只不过他的IO密集型比多线程的IO密集型好一些
#
