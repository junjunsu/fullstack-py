#-*-coding:utf-8-*-
import threading, time

begin = time.time()

def foo(n):
    print('foo%s'%(n))
    time.sleep(1)
    print('end foo')


def bar(n):
    print('bar%s'%(n))
    time.sleep(2)
    print('end bar')

t1 = threading.Thread(target=foo,args=(1,))
t2 = threading.Thread(target=bar,args=(2,))
t1.start()
t2.start()
print('.................in the main')
t1.join()
t2.join()#t1,t2如果不运行结束,它不往下走
end = time.time()
print(end-begin)
#cpu貌似在干两件事情,不是只能干一个活吗?
#并发:
#并行:真正意义上两件事情同时干,2个线程同时跑,2个cpu同时运算,没有任何时间差,遇到IO阻塞可以干点别的事
#串行:cpu从上至下一次执行:花费时间长,c

#通过解释器让os调用cpu去执行
#多核cpu


#书记录页数,行数,单词数,
#记录上下文状态:cpu做的
#
#单核cpu能不能完成一边听音乐,一边看电影?
#单核cpu,两个任务同时交给cpu去做,这叫并发,
#切换,一人执行一会
#执行了100条字节码
#两个线程并发在跑
#第一种情况:小姑先执行,sleep了,能让cpu进行一个转换的过程
#只有两个条件:
#1:AB都有代码要跑,A执行一小段时间,在执行B,不可能一直照顾A
#2:IO阻塞 :socket->accept ,recv  file->read,sleep相当于IO阻塞,当A执行中,CPU还没到切换时间呢,
#A自己有个sleep了,CPU停止,执行B的,因为A有个IO阻塞,不用我cpu了去执行B的,B这执行如果也有IO阻塞,那我再执行别人的,
#如果只有他俩那我就停住了


#线程:看书的例子:看书时候如果我不看了想休息了,把他记下来,让别人去看,别人看完了,如果我还想看按着这个状态继续看就行了

#-------------------------------------------
#进程:一堆资源的整合(多个线程),对这个资源管理的一个集合(线程,变量,占内存的多少),这个整体就是一个进程
#对于计算时的资源整合,进程可以有多个线程
#例子:执行.py文件,这一个进程,有一个线程就是主线程,(前提是不创建子线程)

#线程是可资源共享的,进程不可以共享
#应用软件之间彼此独立,内部线程共享,跟其他进程保持独立

#线程快,还是进程快(.py进程执行快,还是内部线程执行快)
#答:一样快
#线程一堆指令集,资源集合,执行线程跟执行进程是执行一堆同样的东西,线程跟进程执行一堆同样的东西
#我的电脑是多核的,但看起来,我这些代码是1个cpu在执行啊,按理来说应该把3个任务分给3个cpu同时工作啊?为什么不是呢?
#答:不管几核都没有用,

